## 基础算法（1）

### 指南

上课过算法思想，理解

课下：

1. 理解并记忆代码模板
2. 练习题目，提高熟练度，一个题目可以写3-5遍



### 快排

面试常考

l_______________________r

1. 确定分界点：方法q[l]，q[(l+r)/2]，q[r]，随机
2. （重难点）调整区间：使左边所有数小于等于x，右边所有数都大于等于x
3. 递归处理左右两段



重点在于第二步：如何优美地实现？

- 比较暴力的做法：开辟两个额外的空间，扫一遍

![image-20220729164843578](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220729164843578.png)

- 优美的做法

1. 定义左右两个指针i，j
2. 当q[i] < x， i一直往右走，直到q[i]>=x，动j
3. 当q[j] >= x， j一直往左走，直到q[j]<x
4. 交换q[i]和q[j]的值，随后i，j都往中间移动一位。随后循环2-4步，直到i>=j



快排的边界问题（背下来，不要推了）

- 递归的时候，要么是分成(l, i-1), (i, r)；要么是(l, j), (j+1, r)
- 如果是前者，分界点一定不能取q[l]，如果是后者，分界点一定不能取q[r]



### 归并排序

1. 确定分界点mid = (l+r)/2
2. 递归排序left，right
3. （重难点）归并——把两个有序的数列合二为一



第3步做法：

1. 两个指针p，q分别指向left和right的最小值
2. 比较\*p和\*q的大小，小的例如\*q放进res数组，随后q++
3. 循环第2步，直到其中一个指针走完了，没走完的指针后面的元素直接拼到res的后面



### 二分

#### 整数二分

二分的本质：有单调性一定可以二分，但是能二分的不一定非得有单调性。

二分的本质不是单调性，是边界。当check(mid)之后可以确定我们的答案在mid的左边还是右边，就可以用二分



二分思路：

1. 先写一个check函数。用来确定mid值是true还是false
2. 想一下如果check是true或者false，区间应该如何更新
3. 如果check为true时，下一步检索的区间在（mid，r），则mid的公式是l+r+1 >> 1；如果check为true时，下一步检索的区间在(l, mid)，则mid的公式为l+r>>1。核心的点在于，如果下一步更新是l=mid，则要补上+1，如果是r=mid，则不需要+1



总结：不需要考虑太多。思路就是：每次先随便写个mid，然后写个check。然后看看更新的时候是l=mid还是r=mid，如果是l=mid那么就补上+1



二分是一定可以出最后一个结果的，只不过对于题目来说，这个结果可能意味着原问题是无解的。二分法本身是一定有解（会出一个结果）的



#### 浮点数二分

因为不需要考虑边界问题，每次的mid都可以严格除以2

如果要求的精度是两位小数，一般来说退出循环条件就是r-l > 1e-4。-4比要求精度低两位，经验。





## 基础算法（2）

### 高精度

只有c++需要关心

- A+B
- A-B
- A*a
- A/a

len  (a) <= 10^6, a<= 10000



- 大整数怎么存？

把每一位存到数组里面

- 低位存在数组的高下标还是小下标？

低下标，因为高位存在数组的末尾，在进位的时候方便在数组的末尾进行添加



- c++ vector
  - push_back: 就是python的append
  - pop_back: 把vector最后一位弹出
  - back: 取最后一位
- c++ auto：编译器自己推断什么类型。类似js的var

- c++ 形参的&：对于&vector来说，则不会把vector复制一份传进去。只会传vector的引用

#### 大整数加法

模板非常简洁

#### 大整数减法

如果是小数减大数，先判断大小，然后让大数减小数，最后加负号

减法需要把前导0去掉



### 前缀和

定义：就是数列中的Sn

作用：可以很方便求数组中一段元素的和，如Al+...Ar=Sr- Sl-1

前缀和的计算从S1开始，S0定义为0，因此玩前缀和的时候，数组的下标也从1开始。这样就可以统一使用Al+...Ar=Sr- Sl-1这条公式。例如求[1, x]（第1个元素到第x个元素）区间的和，就是Sx-S0，不需要再额外写一个if。（否则的话，没办法S-1，因为S也是一个数组）



二维前缀和

Sij指的是点Sij左上角矩形的和



### 差分

定义：前缀和的逆运算

有数组a1，a2，a3... an

有b数组，使ai = b1 + b2 +... +bn

称bn是an的差分

一维数组构造方法：b1=a1， b2=a2-a1......



构造并不是那么重要。



只要有b数组，就可以O(n)得到an



差分的作用：为原数组的某个区间[l, r]的内的元素全部加上一个数c的时候，只需要使差分数组bl += c， br+1 -= c即可。（这样通过O（1）操作了b数组，在最后用O（n）还原a数组时，就达到了为[l,r]中所有元素+c的效果）

所以使[l, r]中每个元素+c的方法是bl += c， br+1 -= c，构造差分数组bi的方法就是先初始化所有元素是0，使[i, i]的区间中元素+ai。

所以构造差分数组是不需要去想的，只需要想好一般的更新的公式（即往a数组中的某个区间插入c的公式）即可



**Acwing算法竞赛进阶指南**打卡活动，300多道题刷完，算法会到非常高超的水平

**写题解对自己的帮助很大**



## 基础算法三

### 双指针算法

合并两个有序序列时候用

常用模板：

```c++
for(i = 0, j = 0; i < n; i ++)
{
	while(j < i && check(i, j)) j ++;
	//每道题目的具体逻辑	
}
```

核心思想：

```c++
for(int i = 0; i < n; i ++)
	for(int j = 0; j < n; j ++)
		O(n^2)
```

运用某些性质，将上面的朴素算法优化到O(n)



最简单的应用：将abc de fg以每个单词一行的形式输出



双指针问题一般都可以先想一个暴力的做法，然后再通过找i和j的规律去优化

### 双指针：最长不重复子序列

暴力法相当于本来每次i往前移动，j都从0开始扫到i。复杂度on^2

用双指针的算法，j永远表示和i之间最长的子序列，随着i向后移动，j只会向后移动或不移动，而不会回到前面去

 ### 位运算基本操作

#### n的二进制表示中，第k位是几

n = 15 = (1111)2

1. 先把第k位移到最后一位，用n右移k
2. 看一下个位是几，x & 1

结合起来就是：n >> k & 1

#### lowbit：返回x的最后一位1

x = 1010，lowbit(x) = 10

x = 101000, lowbit(x) = 1000;

实现：x & -x

解释：

- -x = (~x + 1)
- x & -x = x&(~x + 1)

举例

x = 1010...1000..00, ~x = 0101...0111..11, ~x + 1 = 0101...1000..00

所以x&(~x + 1) = 1000..00

应用

- 统计x里面1的个数：每次把x里面最后一位1去掉，最后看看去掉了多少次，就是x里面有多少个1



**做题的思考过程**：一个dfs的过程，慢慢把基础算法结合成整个题目的解

![image-20220801222906753](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220801222906753.png)



### 离散化

特指整数的离散化

定义：

有一堆数，值域是0-10^9，个数是10^5

要以这些数为下标的话，很难开辟10^9那么大的数组。

于是把这10^5个数以某种方式映射到0-10^5为下标的数组中。就是把值域10^9的数映射成值域为0-10^5的数

举例：

a[]: 1, 3, 100, 2000, 50000

映射到：0, 1, 2, 3, 4

这个过程就是离散化

问题：

- a[]中可能有重复元素，所以需要**去重**
- 如何算出a[i]离散化后的值是多少。**二分**

离散化是保序的，即离散化完小的离散化完后更小，大的更大

其实离散化就是找一下a[i]中的值的下标。因为a[]是有序的，所以这就是一个二分的操作。

- 先完成排序
- 然后完成去重，使用c++的库函数。先unique()一遍，把重复元素放在数组末尾区间，并返回重复元素区间开始的下标end，然后用erase删掉end后面的元素
- 用二分找出x离散化后的值。找到第一个大于等于x的位置



离散化的应用：区间和

离散化问题的特征：值域的范围/跨度很大，但是很稀疏。

#### 区间和

- 遍历集合

for(auto a : collections) { }

- pair类型：即元组
  - 取第一个元素：pair.first, 第二个：pair.second
  - pair的c++排序会优先以左端点排序，然后以右端点排序
- 定义一个元组类型的vector：typedef pair<int, int> PII



#### 自己实现unique函数(很妙)

unique：对一个有序数组进行去重，返回去重后的区间的末尾元素的下标

用双指针算法

所有最终取出来的数都满足：

- a[0]，或
- a[i] != a[i-1]

思路就是i指针遍历所有元素，如果i满足上面两个条件，a[i] = a[j++]



### 区间合并

把所有有交集的区间合并

1. 按区间左端点排序
2. 遍历所有区间，合并可能的区间

和区间有关的问题大部分都是贪心，基本都是按照左端点或者右端点排序，或者双关键字排序



## 数据结构（1）

主要讲如何用数组模拟。不讲用结构体实现链表，因为new操作会非常慢。在面试中可能用到，笔试中少用。

### 链表与邻接表

1. 单链表：邻接表。最大的用途：存储树和图
2. 双链表：用途：优化某些问题



用数组模拟：

- value数组：e[N]
- next指针数组: ne[N]。空用-1表示

![image-20220802173138550](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220802173138550.png)



代码实现：

- 定义：需要4个变量：

int head, e[N], ne[N], idx;

idx存的是末尾的，下一个被分配的节点（的下标）。head存的是头节点（的下标）

- 操作
  - 插入。例如插入头节点：新的点的next指向head原来指向的值，head指向插入新的点。
  - 删除。直接指向下一个节点的next。不用管释放和内存泄漏的问题



举例：题目：单链表，双链表

### 栈与队列

演示数组模拟栈和队列

单调栈：

给定一个序列，求每一个数左边最近的、比他小的数

做法：每次读入一个数



单调队列：

给定一个序列和一个窗口，窗口不断滑动，求出每次滑动时 窗口里面的最小值

暴力方法：O(nk)





单调队列、单调栈以及双指针的思路：先暴力一波，然后把一些没有用的元素挖出来。

### KMP

下标习惯从1开始

字符串匹配，大字符串A， 小字符串B

核心：预处理B，获得一个next数组。找到B中每个元素以其为后缀的最长的子串，这个子串与B从第一个字符开始的、相同长度的子串完全相等。

![image-20220803010726359](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220803010726359.png)

简称：最大的后缀等于前缀 

## 数据结构（2）

### Tire树

用于高效地存储和查找字符串集合的数据结构

一般用到tire存储的字符串：要么全是数字，要么全是字母，要么全是大写，要么全是小写。总之字符的种类不会很多

![image-20220804112049432](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220804112049432.png)



一般给每个单词的结尾的字母标记一下，表示以当前点结尾是有一个单词的。

因为例如上图再插入一个abc，如果不标记就不知道插入了新的单词了



tire的查找：当在树中没法走下去，或者走到了一个节点但没有标记，就说明点不存在



**树的数组实现**：用一个二维数组，每行表示一个节点，行中的每个元素表示该节点指向的节点

同样，行的idx代表该节点的“地址”

0节点既代表根节点（第0行），也代表空节点（当其他节点指向0时 ，意为指向空）



c++中利用字符串结尾的\0用于遍历字符串的方法

```c++
for(int i = 0; str[i]; i ++) {  }
```



两个关键数据结构：一个二维数组用来描述tire树，一个一维数组用来存储每个节点是否有



### 并查集

面试很大概率出。

代码短，思维性比较强

**并查集两个操作：**

- 将两个集合合并
- 询问两个元素是否在一个集合中

并查集可以在**近乎**O(1)的复杂度下支持上面两个操作



实现：

1. 用树的形式维护一个集合。每个集合都是一棵树。根节点的编号就是集合的编号
2. 每个点存储它的父节点，p[x]表示x的父节点



问题1： 如何判断根节点？if(p[x] == x)。让树根的p[x]为自己

问题2：如何求x的集合编号：while(p[x] != x) x = p[x]

问题3：如何合并两个集合？假设px的x的集合编号，py是y的集合编号，只用p[x] = y即可



因为问题2的存在，此时时间复杂度仍然较高。

**路径压缩优化：**：当一个元素找到了根节点后，搜索路径上的所有节点都直接指向根节点。

![image-20220804230023110](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220804230023110.png)

**按质合并**：没讲，一般用不到，没有啥用



scanf读入字符的时候会读入一些空格和回车，所以哪怕读入一个字符，用scanf，也用字符串%s来读



如果需要维护集合的一些信息，例如维护每个集合的元素数量。只要再定义一个数组，在初始化的时候初始化每个集合的元素个数，集合合并的时候更新，就可以了



并查集只需要牢记find函数就可以了



### 堆

讲手写堆



堆的基本操作

1. 插入一个数
2. 求集合中的最小值
3. 删除最小值
4. 删除任意一个元素（STL堆没实现）
5. 修改任意一个元素（STL堆没实现）



堆是一个完全二叉树

小根堆：每个点都是小于左右儿子的。根节点是整棵树的最小值



堆的存储：和前面链表的存储方式不同，是全新的：用一个一维数组去存。完全二叉树都是这么存的

1号点（下标也是1）都是根节点。x的左儿子：2x；x的右儿子：2x+1



堆的两个基本操作，上面的5个操作都可以用这两个操作实现：

down(x)：如果一个值变大了，就把它往下移。让该数和自己的左右儿子中小的点交换，直到不能交换

up(x)：如果一个值变小了，就把他往上走。让该数和自己的父节点比较，如果比父节点就交换，直到不能交换



实现：

- 插入一个数：在堆最后的位置插入一个数，然后不断up
- 求堆的最小值：heap(1)
- 删除最小值：把堆最后的元素移到堆顶，再down一遍堆顶。这样做的原因是在数组中最后一个节点容易删除。

- 删除任意一个元素：和删除根节点类似。把堆最后的元素移到对顶。判断一下是变大还是变小了，变大了down，变小了up，或者直接down一遍再up一遍，反正也只会执行其中一个。
- 修改一个元素：修改元素之后，down一遍再up一遍



建堆：先把所有数放到数组里面，然后把2/n开始到1，down一遍即可。这里的时间复杂度是O(n)

应用：堆排序

## 数据结构（3）

### 哈希表

哈希表的作用：把一堆比较庞大、复杂的数据，映射到一个比较小的范围

哈希函数：使得hash(x) = y，y的值域小于x的值域。

哈希函数怎么写？

- 最简单的方法：取模。如x mod 1e5
- 冲突。当hash(x1)和hash(x2)相等，如何处理冲突。那就是开放寻址法和拉链法两种



取模一般取的是质数，这样冲突概率最小

离散化是非常特殊的哈希方式，需要保序。

#### 哈希表的存储结构

- 开放寻址法

1. 只开一个一维数组。长度一般是数据范围的2-3倍（经验值）
2. 插入：h(x) = k，看看k有没有坑位，有就找下一个，直到找到空为止。（像上厕所）
3. 查找：看a[k]是不是x，如果不是x就往下找。如果为空就找不到，返回x本应该存储的位置
4. 删除：查找x并打一个标记。并不是真正删除。
5. 约定一个null值

- 拉链法实现

1. 开一个10^5的数组
2. 每一个位置都拉一条链，用来存储被映射到当前位置的所有数  



实现中需要注意的一点：虽然有多个单链表，但是只需要像保存一个单链表一样只用两个数组就可以了。

说白了，多个单链表也是一个图，而前面的并查集（多棵树组成，每个节点只保存自己的父节点）也是一个图。只要一个点只有一个出度的图，都可以用一个一维数组保存。

而如果一个节点有多个出度，如tier树中的保存方式，每个节点存自己的子节点，则需要用一个二维数组去存。

核心：数组中的下标i（二维数组则是行下标）是节点的地址，数组中下标对应元素a[i]保存的是指向的点的地址



**给数组快速设置初始值：memset()**

- #include<cstring>
- memset(arr_name, init_value, size of arr_name);
- memset是按自己来memset的。如果一个数组是int类型（4字节），memset(arr, 0x3f, size of arr)之后，每个int就会变成0x3f3f3f3f。memset常见的赋值成0，每个字节都是0，因此每个int都是0；memset为-1时，c++里-1表示为1111，所以int每一位都是1，int也为-1
- memset不能处理vector

#### 字符串哈希方式

字符串前缀哈希法

建一个数组，h[i]保存了包含前i个字符的字符串的哈希值

1. 把字符串看成p进制的数，如果字符串有8种字符，那么就是8进制
2. 转换成10进制的数
3. 整个数mod一个Q。这样就可以把任何一个字符串转换成0-Q-1的数



注意：字符串哈希是完全不考虑冲突的。经验值，此时P=131或1331；Q=2^64



核心在于字符串的哈希值就是把字符串转换成一个数的方式。上面只是理论，是为了让不同的字符串不产生冲突



用途：求任意一字符串子串的的哈希值。其实和前缀和非常类似。不同的是前缀和的s[i]表达的是i前面所有元素的和。而字符串哈希的h[i]表达的是i前面的所有字符所转化成的数字。因此在转换成中间某一段的时候，转换的计算会略有不同



这是一个处理字符串的利器。很多很困难的题目都可以用这个方法过掉。

**当要快速判断两个字符串是不是相等的时候，就可以用这个方法。**

### STL

#### vector

变长数组，倍增的思想：

当os为某程序分配空间，所需时间基本上与空间大小无关，与申请次数有关。

一次申请长度1000的数组和申请1000次长度是1的数组，时间可能差1000呗。

因此申请空间的时候尽量申请次数少，浪费点没关系。

每次申请的时候，申请长度是目前长度的2倍，然后把原来的树copy到新的数组。

如果长度是n，申请次数大概是logn，均摊下来每个元素copy的时间大概是O(1)。

初始化方式

vector<int> a;

定义长度为n的vector：vector<int> a(10)

定义长度为n的vector而且每个数初始化为x，vector<int> a(10, x)

看大小：a.size()

看是否为空：a.empty()

*size和empty所有容器都有，时间复杂度O(1)*

清空：a.clear()。并不是所有容器都有

front()/back()

push_back()/pop_back()

迭代器：begin()/back()

支持随机访问：[]

三种遍历方式：随机访问遍历，迭代器遍历，find遍历：

![image-20220806165904846](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220806165904846.png)



vector支持比较运算：两个vector可以比较大小，按字典序来比

#### pair

存储二元组

前后两变量类型可以任意

p.first

p.second

支持比较运算，按字典序，以first为第一关键字，second为第二关键字

构造pair

​	p = make_pair(10, "yes")

​	p = {20, "abc"}



存储三个东西：pair<int, pair<int, int>>

#### string

size()/ length()

字符串可以 += 另一个字符串

substr(起始下标，长度)：返回某一个子串，当长度很大或省略，则从起始输出到结束为止

如果用printf输出

 c_str()：返回字符数组的起始地址。printf("%s", s.c_str)

#### queue

#include<queue>

插入队尾元素push()

弹出队头元素pop()

返回队头元素front()

返回队尾元素back()

有size、有empty，没有clear

#### priority_queue

优先队列，是一个堆

插入元素：push()

返回堆顶元素top()

弹出堆顶元素pop()

没有clear

默认大根堆，用小根堆的话，可以插入-x，或者

priority_queue<int, vector<int>, greater<int>>

#### stack

push(), top(), pop()

#### deque

双端队列，队头队尾都可以插入删除。而且可以随机访问

clear()

front(), back()

push_back(), pop_back()

push_front(), pop_front()

begin, end

[]

缺点：比较慢

#### set, map, multiset, multimap

基于平衡二叉树（红黑树）。动态维护有序序列

size()

empty()

clear()

begin()/ end()， 而且迭代器可以++ --

set/multiset

- multiset可以有重复元素

- insert() 插入一个数
- find() 查找一个数
- count() 返回某一个数的个数
- erase()
  - 输入一个数x，则删除所有x
  - 输入一个迭代器，删除这个迭代器
- lower_bound()/ upper_bound()
  - lower_bound()返回大于等于x最小的数
  - upper_bound()返回大于x的最小的数

map/multimap

- #include<map>

- insert() 插入的是一个pair
- earse() 插入pair或迭代器
- find()
- []：数组一样用map。时间复杂度log(n)

#### unordered_set, unordered_multiset, unordered_multimap, unordered_map, 

基于哈希表实现

和上面的都类似，但增删改查都是O(1)

但不支持lower_bound() / upper_bound()。因为没有维护大小序列

也不支持迭代器的++ --

#### bitset

压位

例如，存1024个bool，由于bool在c++中是一个字节（8bit），所以要1KB

但是可以用bitset存，省8倍空间

bitset<10000> s;

~ & | ^

左移>>, 右移<<

--, !=

[]

count() 返回有多少个1

any() 判断是否至少有一个1

none() 判断是否全为0

set()把所有位置成1

set(k, v) 把k位变成v

reset()把所有位变成0

flip() 等于~

flip(k) 把k位取反



## 搜索与图论（1）

### dfs bfs

数据结构：dfs栈、bfs队列

空间：dfs O(n)， bfs(2^n)

bfs优点：能找到最短路、最短距离的性质。



涉及最短路、最小距离、最少操作几步，基本都是bfs

一般算法思路比较奇怪，对空间要求比较高的，用dfs



dfs重要概念：回溯、剪枝

dfs最需要考虑的问题：顺序。用什么顺序来遍历



回溯的时候一定要注意**恢复**

剪枝：就是中途停止。提前判断不合法，就直接回溯，不用遍历到子节点 



实现上，dfs基本就是递归实现



最短路问题（无权的话）用bfs做

DP问题和最短路问题其实是互通的

最短路问题包含DP问题。



dfs一般没有常用框架，但是bfs一般都有

```c++
queue.init
while queue is not null
{
	t = queue.head
	queue.expand
}
```

 

怎么输出路径：开一个二维数组，记录每一个点的前导点是什么

### 树与图的存储、遍历

树是特殊的图



无向图是特殊的有向图。如果是无向图，建两天边就可以了

有向图的存储

- 邻接矩阵（用的少），适合存稠密图
- 邻接表：和哈希中的拉链法一样。有n个点就开n个单链表。链表中存该点可以到什么点。
  - 单链表内部的次序无关紧要
  - 要额外建一个头节点数组（存的是每个链表的第一个节点的idx），保存各个点所对应链表的头节点，这和拉链法是不一样的。拉链法各链表的头节点都是直接map到的，不需要存储
  - 三个数据结构：链表头节点数组保存h[N], 链表元素数组保存边的出度e[N], 链表next数组ne[N]



这里说的树指的是树形态的图。是一种一般的树，所以可以用存无向图的方式去存，每条边存两次。

而前面用过的tier树、并查集用到的树，以及一些其他特殊的树，只需要存储节点的儿子；或者只需要存储节点的父亲的，就只用一个一维数组（去存父节点），或者让二维数组（去存儿子节点）



此时的idx，是当前点 指向的点 的下标。虽然说根据idx找到的是点的编号，但是idx实际上的意义是边。因为idx是这么来的：每有一条边，链表中分配一个节点，该节点的内容是边指向的点编号，然后把该节点插入边起点的点的链表中

### 

在bfs中找节点的最短路径，如何保存每个节点到头节点的距离？

- 定义一个一维数组d，保存每个节点到头节点的距离。当前节点i的距离d[i] = d[前驱点] + 1



bfs的应用：有向图的拓扑排序

有向无环图DAG一定存在拓扑序列

所有入度为零的点都可以排在最前面

bfs框架解决：

```
所有入度为0的点入队
while queue is not null
{
	t = queue.head
	枚举t的出边j
	{
		d[j] --; //j 入度--。
		if d[j] == 0
			j入队 //意思是：假如j只有t一个入边。那么在拓扑序中j只需要保证在t后面即可。此时t已经输出了，所以j也可以随时输出。即如果j有多个入边，当j入度为0，j就可以输出（入队）了
	}
}
```

一个DAG一定至少存在一个入度为0的点

技巧点：

- 用数组模拟队列，最后的拓扑序刚好就在队列数组中，因为出队的时候只是++了头指针

- 可以用最后队列的长度 == 元素个数，判断是否是有环。如果有环，上面的算法一定会中途退出，导致队列中少了形成环的元素。



## 搜索（2）

点为n，边为m

最短路问题的分类

- 单源最短路：求一个点到其他点最短路
  - 所有边权都是正的
    - 朴素dijkstra算法。O(n2) 。时间复杂度和边没有关系。所以适合稠密图
    - 堆优化dijkstra算法。O(mlogn)。稠密的时候m接近于n^2，所以接近与n^2 logn
  - 存在负权边
    - bellman-ford O(nm)
    - SPFA 一般：O(m)，最坏O(nm)
- 多源汇最短路：源就是起点，汇就是终点。当起点和终点都是任意的，就是多源汇最短路
  - floyd算法



不需要证明算法的正确性。，最短路问题一共就这么几种算法。

重点在：建图。如何把原问题抽象成最短路问题，从而套用模板

### 朴素dijkstra

结合s：所有当前已确定最短距离的点

1. dis[1] = 0, dis[i] = +∞
2. for i : 0 - n





## DP（1）

有套路，有y氏理解方式

考的常用模型不多

常用模型：

1. **背包问题：大部分dp问题都是背包问题模型。重点**
2. 线性dp、区间dp
3. 状态压缩dp
4. 计数类dp等等



### 背包问题

n个物品，每个物品有体积v和价值w

01背包问题：每件物品只能用0或1次

完全背包问题：每件物品有无限个

多重背包：每个物品最多有si个

​	朴素版、优化版

分组背包：物品分成很多组，每组只能选一个



### 01背包问题

- 状态表示。每一个状态怎么表示？有几维（有几维），每个状态的含义是什么，可以从两个角度考虑
  - 保存的集合是什么？每一个状态对应一个什么样的（自变量的）集合？01背包里面，f(i, j)表示从前i个物品中选，总体积小于等于j。满足以下两个条件的所有选法，他们就是f(i, j)的这个集合
    - 只从前i个物品中选
    - 选出来物品总体积<=j
  - 存的数f(i, j)表示集合的什么属性？一般有**最大值**、最小值、数量。01背包中，就是要找出f(i, j)集合中物品价值的最大值
- 状态计算。怎么把状态一步一步算出来——集合的划分。把f(i, j)表示的所有选法（即f(i, j）所代表的选法的集合）划分成不同的子集。子集的划分：不重、不漏。不漏一定要满足。
  - 把f(i, j)划分成两个子集，1是不包含第i个物品，2是包含第i个物品，
    - 如果不包含第i个物品，那么f(i, j) = 从前i-1个物品中选，总体积小于等于j，即f(i- 1, j)
    - 如果包含第i个物品，思考方式可以是先算除去i，再加上i。那么f(i, j) = 包含i个物品前提下，前i-1个物品价值的最大值，f(i - 1, j - wi)，加i的价值。即f(i - 1, j - wi) + vi

所有背包问题都可以划分成上面的方式去考虑

Dp的优化一般是对状态计算的等价变形



01背包优化：因为每次都只用到了f(i - 1)，所以可以用滚动数组来做，把二维的f(i, j)变成一维。然后对代码做**等价变形**。在做等价变形的时候不需要考虑dp本身的意义什么的，只要保证代码的逻辑和变形前一样就可以。

基本做法就是在遍历j层的时候，当前f(j)数组就相当于优化前的f(i-1, j)，当前j层遍历完后，f(j)就变成了相当于之前的f(i, j)。

有需要注意的点就是，变形后j应该从后往前遍历，为了保证f(j - v[i])还没有被当前的遍历覆盖过（如果覆盖过就相当于是f(i, j - v[i])，而不是我们想要在现在使用的、上一轮遍历产生的f(i-1, j - v[i]了）



### 完全背包

- 状态表示
  - f(i, j)的集合：只考虑前i个物品，且总体积不大于j的所有选法
  - f(i, j)属性：集合里面所有选法总价值的max
- 状态计算：集合的划分。完全背包问题以第i个物品选x个划分成x个子集。如果x最多=k，那么子集就有k + 1（0~k）
  - 当i选了0个，f(i, j) = f(i - 1, j)
  - 当i选了k个，三步走
    - 去掉k个物品i
    - 求去完之后这些选法的max，f(i-1, j - k*v[i])
    - 再加回k个物品i



优化： 通过对转移方程进行数学上的合并，从而少了一层k的循环：

![image-20220811154617759](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220811154617759.png)

完全背包和01背包的状态方程对比，仅仅在于第二项，01是从i-1转移，完全背包是从i转移

![image-20220811154817845](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220811154817845.png)



可以继续优化成一维。而优化为一维之后，01背包问题那个优化后的“错误”刚好在这里是正确的。即j从小向大遍历，到f[j-v]的时候，由于前面的已经被这轮遍历覆盖了，所以正好就是f(i, j - v)

结果来看和01背包唯一的区别就是**内层循环的顺序**



### 多重背包

1. 状态表示f(i, j)
   1. 集合：所有只从前i个物品，并且体积不超过j的选法
   2. 属性：Max
2. 状态计算：0-min(最大数量，超重数量 )



不能用完全背包问题的方式去优化，因为物品数量有限，并不能得出完全背包优化时候理想的式子



二进制优化：对于一种物品，有k个，可以把这些物品分成n个组，每个组都可以选0或1次，使得n个组无论怎么去选都可以最终得到0-k个物品。此时n = logk。对所有种类的物品都进行这样的操作，把每一个组都看成新的物品。然后解决01背包问题



### 分组背包

1. 状态表示f(i, j)
   1. 集合：表示前i组物品中，体积不大于j的所有选法
   2. 属性：max
2. 状态计算：f(i, j)划分。
   1. 第i组一个都不选f(i - 1, j)
   2. 第i组中选第k个物品f(i - 1, j - v[ik]) + w[ik]



## DP（2）线性DP

线性dp：状态方程求解的时候有明显的线性顺序，比如都是一行一行求的，那么就是线性dp



### 数字三角形

1. 状态表示f[i, j]
   1. 集合定义（感觉这是最难的，只要定义正确率了，后面的都可以推了）：f[i, j]表示所有从起点走到i,j这个点的路径
   2. 属性：路径的最大值
2. 状态计算：f[i, j]可以分为两类：从左上来的一类和右上来的一类。f(i, j) = max(f(i-1, j - 1) + a[i, j], f(i - 1, j + 1) + a[i, j])



**下标从0还是1开始**一般是：当计算的时候出现了i-1的下标，那么就下标可以从1开始，然后给下标0设一个默认值。



dp时间复杂度：状态数量（即f[i, j]中i，j的枚举次数）*转移计算量（每次f[i, j]的计算次数）



**负无穷c++：-INF**

  

### 最长上升子序列

- 状态表示
  - 集合：所有**以第i个数结尾**的上升子序列
  - 属性：max
- 状态计算：以**倒数第二位数是什么**划分集合。所以最多有i次划分（没有数~i-1）

时间复杂度：O(n^2)

怎么输出最长上升子序列（dp求最优路径）：多定义一个数组，在转移的时候把转移记录下来



另一种解法（？）

- 状态表示
  - 集合：前i个数中的所有上升子序列
  - 属性：集合中所有序列中，最长序列的最后一位数
- 状态计算：if(a[i] > f[i-]) f[i] = a[i]; else f[i] = f[i - 1]



**dp问题很看经验**



### 最长公共子序列

- 状态表示
  - 集合：所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的，公共子序列
  - 属性：Max
- 状态计算：以a[i]和b[j]是否在子序列中，划分为四个情况

![image-20220812142357954](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220812142357954.png)

f[i-1, j]和f[i, j-1]这两个状态并不是严格表示01和10的状态。但是包含了他们。因为最终是要求max，所以有重复其实没有关系。

而f[i-1, j-1]一般不写，因为这个集合被包含在f[i-1, j]和f[i, j-1]中。

用集合的角度理解f[i, j]是解释上面这种“将错就错”现象的最好办法。



一般两个字符串的问题，一般都可以这么表示。



*关于int数组和char数组的保留节目*

int是4字节，char1字节，当把字符串输入到int数组的时候，相当于每4个字符会读到一个int里面





### 石子合并（区间dp）

- 状态表示：所有将第i堆石子到第j堆石子合并成一堆式子的合并方式
- 属性：min
- 状态计算：按照i~j堆石子中所有合并方式的最后一步合并的分界线进行划分。对所有分界线的方式取min

![image-20220812150304005](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220812150304005.png)



区间dp一般写法：

先循环区间长度，再循环区间左端点



## 计数问题

分情况讨论



count(n, x)，1~n中x出现的次数

a-b中x出现的次数：前缀和的思想：count(b, x) - count(a - 1, x)



求1在第4位出现的次数：分类讨论

![image-20220814153326050](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220814153326050.png)





（没看完）



## 蒙德里安的梦想（没太懂，比较难）

 核心：先放横着的，再放竖着的。当把横着的摆完，竖着的只有一种方式往里面塞

**因此总方案数=只放横着的小方块的合法方案数**

如何判断当前方案是否合法：所有剩余位置能否填满竖的方块

可以按列来看，每列内部所有连续的空着的小方块，需要是偶数个



**dp：先化零为整，后化整为零。**先把各个方案归到一个状态中去，再把每个状态分割成若干个子集，然后去求

- 状态表示：f[i, j]表示已经将前i-1列摆好，且从第i-1列，伸出到第i列的所有方案





## 贪心（1）

贪心的算法不一定有严格的证明

### 区间选点

贪心的大概思路：大概试一些做法。

例如**区间问题：一般都是排序，左端点排序、右端点排序、双关键字排序**

然后可以去举一些例子，如果没有问题就尝试去证明



1. 将每个区间按右端点从小到大排序
2. 从前往后枚举每个区间
   1. 如果当前区间中已经包含点，则pass
   2. 否则，选择当前区间的右端点（这就是贪心，因为这个点“看上去最有希望”）



证明：

假设上面统计出的点个数是cnt，而答案是ans

- 按上面的选法，每个区间都一定至少有一个点，所以cnt >= ans
- 同时按照上面的选法，我们找到了cnt个完全没有交集的区间，并且保证这cnt个完全没有交集的区间上都有一个点。而ans是要每个区间都至少有一个点，所以ans >= cnt
- 所以ans = cnt



对区间用右端点排序：

定义一个sturct保存区间的左右端点，然后重载区间的<号



贪心就是比较短视的算法，每次都在局部找最优解



## 最大不重复区间

和上一题的解法一模一样

证明：

- 首先cnt选出了cnt个不重复的区间，所以cnt一定是一个可行方案。而ans是可行方案里面的最大值，所以ans >= cnt
- 假设ans > cnt，意味着可以选出ans个不重复的区间。但是按照上一题的证明，cnt个点一定可以都落在每一个区间里面，如果有ans>cnt且有ans个不重复区间，则不可能让cnt个点同时落在ans个区间中。所以ans <= cnt



如果模型很难证，就要记住适当的代码。



### 区间分组（111畜栏预定）

![image-20220814180411407](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220814180411407.png)

证明：

1. 首先这样一定是一个合法方案。所以cnt >= ans
2. 按照上面的分发，每个组之间都一定会有交集，这是因为，例如，第二组的出现一定是因为和第一组有交集，第三组的出现一定是因为和1、2组有交集，即第n组的出现一定是因为和前n-1都有交集，所以所有组两两之间都一定会有交集。所以cnt个组都不可能被合并，所以至少要分成cnt个组，所以cnt <= ans。（还是感觉不太严格，主要是怎么严格证明有没有别的分配方法，不需要cnt那么个多组呢） 



动态维护一个序列的最小值：用堆。



贪心做法：猜+证明

### 区间覆盖

![image-20220814185713264](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220814185713264.png)



证明1：20：00



### 合并果子

哈夫曼树：最终的值和节点的层数有关

![image-20220814192413432](C:\Users\Aaron\AppData\Roaming\Typora\typora-user-images\image-20220814192413432.png)

每次挑两个值最小的数合并
